#! /bin/bash
set -eo pipefail
IFS=$'\n\t '
DIR="$( cd "$( dirname "${BASH_SOURCE[0]}" )" >/dev/null && pwd )"

export PATH=${PATH}:~/bin

KUBECTL_VERSION=v1.16.6
HELM_VERSION=v2.16.1
HELMDIFF_VERSION=v2.11.0+5
JQ_VERSION=1.5
YQ_VERSION=2.1.2

INSECURE_REGISTRY=''
CONTAINER_REGISTRY=''

PRIMEHUB_HEML_CHART="https://charts.infuseai.io/index.yaml"
SUPPORT_K8S_VERSION="1.15 1.16 1.17"
K8S_VERSION=1.17
PRIMEHUB_VERSION=v2.6.2
PRIMEHUB_NAMESPACE=hub
PRIMEHUB_SCHEME='http'
PRIMEHUB_PATH=
PRIMEHUB_MODE='ee'
LICENSE_PATH=

HELM_TIMEOUT=1000
DOMAIN_CHECK=true

info() {
  echo -e "\033[0;32m$1\033[0m"
}

warn() {
  echo -e "\033[0;93m$1\033[0m"
}

error() {
  echo -e "\033[0;91m$1\033[0m" >&2
}

primehub_config_path() {
  local CONFIG_PATH=~/.primehub/config/$(kubectl config current-context)
  echo "${CONFIG_PATH}"
}

prepare_env_varible() {
  local name=$1
  local val=$(eval 'echo $'$name 2> /dev/null);
  if [[ ${val} ]]; then
    echo "$name = ${val}"
  else
    printf "Please enter ${name}: "; read ${name}; if [ "$(eval 'echo $'$name 2> /dev/null)" == "" ]; then echo "${name} not set"; return 1; fi
  fi
}

usage (){
    local SELF=`basename $0`
    cat <<EOF
USAGE:
  $SELF create  singlenode  [options]            : Create single-node k8s environment
  $SELF status  singlenode                       : Show the statuse of single-node k8s environment
  $SELF destroy singlenode                       : Destroy single-node k8s environment
  $SELF create  primehub  [options]              : Install PrimeHub based on single-node k8s environment
  $SELF status  primehub                         : Show the statuse of PrimeHub
  $SELF diff    keycloak                         : Show the helm diff of Keycloak
  $SELF diff    primehub                         : Show the helm diff of PrimeHub
  $SELF destroy primehub                         : Uninstall PrimeHub
  $SELF destroy keycloak                         : Uninstall Keycloak
  $SELF license                                  : Show the license of PrimeHub
  $SELF apply-license [--license_path]           : Apply the license of PrimeHub
  $SELF -h,--help                                : show this message

Options:
  --namepace          <primehub-namespace>       : Namespace of PrimeHub install (Default: hub)
  --primehub-version  <primehub-version>         : PrimeHub version (Default: $PRIMEHUB_VERSION)
  --k8s-version       <k8s-version>              : Kubernetes version (Default: $K8S_VERSION, Supported: $SUPPORT_K8S_VERSION)
  --path              <primehub-path>            : Path of PrimeHub release package folder (Default: ${PRIMEHUB_PATH})
  --license-path      <primehub-license-path>    : Path of PrimeHub license
  --enable-https                                 : Enable HTTPS (Default:off)
  --primehub-ce                                  : Install PrimeHub Community Edition
  --insecure-registry <container-registry>       : Enable insecure container registry
  --custom-image      <container-registry>       : Enable image builder feature with giving container-registry
  --helm-timeout      <timeout-second>           : Timeout of helm install (Default: 1000)
  --skip-domain-check                            : Skip the domain name check
EOF
}

search_primehub_package() {
  local version=${1}
  echo $(find . -name "*primehub-${version}.tar*" | head -n1)
}

search_primehub_folder() {
  local version=${1}
  echo $(find . -name "*primehub-${version}" | head -n1)
}

search_primehub_license() {
  find . -name "*license_crd.yml" | head -n1
}

verify_primehub_path() {
  local path=${1}
  if [[ "${path}" != "" && -f "${path}/CHANGELOG.md" ]]; then
    return 0
  fi
  return -1
}

prepare_primehub_release_tarball() {
  local version=${1}
  local target=${2}

  if ! check_primehub_required_bin; then
    warn "[Pre-check Failed] Not install PrimeHub requested app"
    install_primehub_required_bin
  fi

  if verify_primehub_path ${PRIMEHUB_PATH}; then
    info "[Found] manually assign PrimeHub at ${PRIMEHUB_PATH}"
    return 0
  fi

  info "[Search] Folder primehub-${version}"
  if verify_primehub_path $(search_primehub_folder ${version}); then
    PRIMEHUB_PATH=$(search_primehub_folder ${version})
    info "[Found] folder ${PRIMEHUB_PATH}"
    return 0
  fi
  warn "[Not Found] Folder primehub-${version}"

  info "[Search] tarball primehub-${version}.tar.gz"
  local release_tarball=$(search_primehub_package ${version})
  if [[ "${release_tarball}" != "" ]]; then
    info "[Found] tarball ${release_tarball}"
    info "[Extract] ${release_tarball}"
    tar zxf ${release_tarball}
    if verify_primehub_path $(search_primehub_folder ${version}); then
      PRIMEHUB_PATH=$(search_primehub_folder ${version})
      return 0
    fi
  fi
  warn "[Not Found] tarball primehub-${version}.tar.gz"

  info "[Search] primehub helm chart with version: ${version}"
  if curl -s https://charts.infuseai.io/index.yaml  | yq r - 'entries.primehub[*].appVersion' | grep ${version} > /dev/null ; then
    return 0
  fi
  warn "[Not Found] primehub ${version} in infuseai helm chart"

  if [[ "${target}" != "primehub" ]]; then
    warn "[Skip] Don't need PrimeHub release package when target != primehub"
    return 0
  fi

  error "[Fail] Can not found any PrimeHub release package"
  return -1
}

check_microk8s_snap() {
  if ! command -v snap > /dev/null; then
    return -1
  fi
  if [[ "$(snap list | grep microk8s)" != "" ]]; then
    return 0
  fi
  return -1
}

check_microk8s() {
  function check_microk8s_addon () {
    local addon=${1}
    if ! microk8s.status | grep "${addon}: enabled" > /dev/null ; then
      error "[Pre-check Failed] microk8s addons: ${addon} is not enabled"
      exit 1
    fi
  }

  if ! check_microk8s_snap; then
    error "[Pre-check Failed] Not install microk8s"
    exit 1
  fi

  if ! check_primehub_required_bin; then
    error "[Pre-check Failed] Not install PrimeHub requested app"
    exit 1
  fi

  if ! microk8s.status | grep 'microk8s is running' > /dev/null ; then
    error "[Pre-check Failed] microk8s is not running"
  fi

  check_microk8s_addon "rbac"
  check_microk8s_addon "dns"
  check_microk8s_addon "storage"
}

check_k8s_cluster() {
  if kubectl version --request-timeout=3 > /dev/null; then
    return 0
  fi
  return -1
}

check_primehub_required_bin() {
  if [[ "$(command -v yq)" != "" && "$(command -v helm)" != "" && "$(command -v kubectl)" != "" ]]; then
    return 0
  fi
  return -1
}

install_primehub_required_bin() {
  mkdir -p ~/bin
  if [[ "${PRIMEHUB_PATH}" == "" ]]; then
    info "[Install] primehub required bin"
    pushd ~/bin
    info "[Download] kubectl ${KUBECTL_VERSION}"
    curl -O -L "https://storage.googleapis.com/kubernetes-release/release/${KUBECTL_VERSION}/bin/linux/amd64/kubectl" && chmod +x ~/bin/kubectl

    info "[Download] yq ${YQ_VERSION}"
    curl -o yq -L "https://github.com/mikefarah/yq/releases/download/${YQ_VERSION}/yq_linux_amd64" && chmod +x ~/bin/yq

    info "[Download] helm ${HELM_VERSION}"
    curl -O -L "https://storage.googleapis.com/kubernetes-helm/helm-${HELM_VERSION}-linux-amd64.tar.gz"
    mkdir -p ~/bin/helm-${HELM_VERSION}
    tar zxf helm-${HELM_VERSION}-linux-amd64.tar.gz -C ~/bin/helm-${HELM_VERSION}
    mv ~/bin/helm-${HELM_VERSION}/linux-amd64/helm ~/bin/helm
    rm -rf ~/bin/helm-${HELM_VERSION}
    rm ~/bin/helm-${HELM_VERSION}-linux-amd64.tar.gz

    info "[Download] helm-diff ${HELMDIFF_VERSION}"
    curl -O -L "https://github.com/databus23/helm-diff/releases/download/${HELMDIFF_VERSION}/helm-diff-linux.tgz"
    mkdir -p $(helm home)/plugins
    tar -C $(helm home)/plugins -xf ~/bin/helm-diff-*.tgz
    rm -f ~/bin/helm-diff-*.tgz

    popd
  else
    info "[Install] primehub/bin"
    cp -r ${PRIMEHUB_PATH}/bin/* ~/bin
    mkdir -p $(helm home)/plugins
    tar -C $(helm home)/plugins -xvf ${PRIMEHUB_PATH}/bin/helm-diff-*.tgz
  fi
}

create_singlenode() {
  if ! check_microk8s_snap; then
    warn "[Pre-check Failed] Not install microk8s"
    info "[Install] microk8s"
    sudo snap install microk8s --classic --channel=${K8S_VERSION}/stable
    info "[Add] current user $USER to group microk8s"
    sudo usermod -a -G microk8s $USER

    warn "[Require Action] Please relogin this session and run create singlenode again"
    exit 1
  fi

  if ! check_primehub_required_bin; then
    warn "[Pre-check Failed] Not install PrimeHub requested app"
    install_primehub_required_bin
  fi

  info "[check] microk8s status"
  local status=$(microk8s.status --wait-ready)

  if echo ${status} | grep "storage: disabled" > /dev/null; then
    info "[Enable] microk8s addon: storage"
    microk8s.enable storage
  fi  

  if echo ${status} | grep "dns: disabled" > /dev/null; then
    info "[Enable] microk8s addon: dns"
    microk8s.enable dns
  fi

  if echo ${status} | grep "rbac: disabled" > /dev/null; then
    info "[Enable] microk8s addon: rbac"
    microk8s.enable rbac
  fi
  
  microk8s.status --wait-ready
  info "[check] enable 'privileged' in kube-apiserver"
  privileged=$(cat /var/snap/microk8s/current/args/kube-apiserver | grep '\-\-allow-privileged' || true)
  if [[ "${privileged}" == "" ]]; then
    warn "[Pre-check Failed] Not enable 'privileged' in kube-apiserver"
    info "[Enable] 'privileged' in kube-apiserver"
    echo "--allow-privileged" >> /var/snap/microk8s/current/args/kube-apiserver
    info "[Restart] microk8s ..."
    microk8s.stop
    microk8s.start
  fi

  if [[ "${INSECURE_REGISTRY}" != "" ]]; then
    info "[Enable] Insecrue registry ${INSECURE_REGISTRY}"
    local mirror=$(cat << EOF
        \[plugins.cri.registry.mirrors."${INSECURE_REGISTRY}"\]\n          endpoint = \[\"http:\/\/${INSECURE_REGISTRY}\"\]
EOF
)
    sed -i "s/\[plugins.cri.registry.mirrors\]/\[plugins.cri.registry.mirrors\]\n${mirror}/" /var/snap/microk8s/current/args/containerd-template.toml
    info "[Restart] microk8s ..."
    microk8s.stop
    microk8s.start
  fi

  info "[Check] kube config"
  mkdir -p ~/.kube
  microk8s.kubectl config view --raw > ~/.kube/config
  kubectl get node

  info "[check] k8s cluster"
  kubectl cluster-info
  info "[check] k8s node"
  kubectl get node

  info "[Apply] Helm rbac"
  kubectl apply -f - << EOF
apiVersion: v1
kind: ServiceAccount
metadata:
  name: tiller
  namespace: kube-system
---
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRoleBinding
metadata:
  name: tiller
roleRef:
  apiGroup: rbac.authorization.k8s.io
  kind: ClusterRole
  name: cluster-admin
subjects:
  - kind: ServiceAccount
    name: tiller
    namespace: kube-system
EOF

  info "[Init] Helm"
  helm init --service-account tiller --wait
  helm version

  info "[Check] Storage Class"
  kubectl get storageclass

  info "[Check] Nginx Ingress"
  if [[ $(helm ls nginx-ingress) == "" ]]; then
    info "[Install] Nginx Ingress"
    helm install stable/nginx-ingress --namespace ingress-nginx \
    --name nginx-ingress --set controller.hostNetwork=true --set rbac.create=true
  fi
  kubectl -n ingress-nginx rollout status deploy/nginx-ingress-controller
  kubectl get svc -n ingress-nginx

  info "[Check] Metacontroller"
  install_metacontroller

  info "[Completed] Create Single Node"
}

status_singlenode() {
  check_microk8s

  info "[K8S] Node Status"
  kubectl get node -o wide
  info "[StorageClass] Storage Class"
  kubectl get storageclass
  info "[Helm] Helm list"
  helm ls

}

destroy_singlenode() {
  local CONFIG_PATH="$(primehub_config_path)"

  if ! check_microk8s_snap; then
    error "[Pre-check Failed] Not install microk8s"
    exit 1
  fi
  info "[Destroy] Single Node Kubernetes Cluster"

  verify_action "Single Node Kubernetes Cluster" "yes-i-really-mean-it"

  info "[Backup] config"
  backup_config

  info "[Destory] Kubernetes Cluster "
  sudo snap remove microk8s

  info "[Remove] config"
  rm -rf ${CONFIG_PATH}
  info "[Done]"
}

usage_PRIMEHUB_DOMAIN() {
  error "Please provide a domain name which can access to your cluster. (Ex. primehub.example-domain.com)"
  warn "For more detail information, please access https://docs.primehub.io/docs/next/getting_started/install_primehub to get help."
}

preflight_check() {
  info "[Preflight Check]"
  check_infrastructure

  echo "DATA" | nc localhost 80 > /dev/null || (error '[Pre-check Failed] Ingress is not running'; exit 1)

  kubectl get sc > /dev/null || (error '[Pre-check Failed] Storage Class is not configurated'; exit 1)

  info "[Preflight Check] Pass"
}

init_env() {
  local CONFIG_PATH="$(primehub_config_path)"
  local envpath="$CONFIG_PATH/.env"

  if [[ -f $envpath ]]; then
    warn "[Skip] ${CONFIG_PATH}/.env is found"
    return
  fi
  info "[Create] ${CONFIG_PATH}/.env"

  # generate random
  ADMIN_UI_GRAPHQL_SECRET_KEY=${ADMIN_UI_GRAPHQL_SECRET_KEY:-$(openssl rand -hex 32)}
  HUB_AUTH_STATE_CRYPTO_KEY=${HUB_AUTH_STATE_CRYPTO_KEY:-$(openssl rand -hex 32)}
  HUB_PROXY_SECRET_TOKEN=${HUB_PROXY_SECRET_TOKEN:-$(openssl rand -hex 32)}
  PH_PASSWORD=${PH_PASSWORD:-$(openssl rand -hex 12)}

  PRIMEHUB_NAMESPACE=${PRIMEHUB_NAMESPACE:-hub}

  local keys=(
    PRIMEHUB_NAMESPACE

    PRIMEHUB_DOMAIN
    PRIMEHUB_SCHEME
    PRIMEHUB_STORAGE_CLASS
    PH_DOMAIN
    PH_SCHEME

    KC_DOMAIN
    KC_SCHEME
    KC_USER
    KC_PASSWORD
    KC_REALM

    ADMIN_UI_GRAPHQL_SECRET_KEY

    HUB_AUTH_STATE_CRYPTO_KEY
    HUB_PROXY_SECRET_TOKEN

    PH_PASSWORD

    PRIMEHUB_AIRGAPPED

    PRIMEHUB_CONTROLLER_CUSTOM_IMAGE_REGISTRY_ENDPOINT
    PRIMEHUB_CONTROLLER_CUSTOM_IMAGE_REGISTRY_USERNAME
    PRIMEHUB_CONTROLLER_CUSTOM_IMAGE_REGISTRY_PASSWORD
    PRIMEHUB_CONTROLLER_CUSTOM_IMAGE_REPO_PREFIX
  )

  touch ${envpath}
  echo "" > ${envpath}
  for key in "${keys[@]}"; do
    if [[ -z ${!key+x} ]]; then
      continue
    fi
    echo "$key=${!key}" >> ${envpath}
  done

  chmod 600 ${envpath}
}

verify_primehub_domain() {
  local domain_name=$1
  local scheme=${PRIMEHUB_SCHEME}
  local primehub_url="${scheme}://${domain_name}/healthz"

  if [[ ${DOMAIN_CHECK} != true ]]; then
    warn "[Skip] Domain Name Check: ${primehub_url}"
    return 0
  fi

  info "[Verify] Domain Name: ${primehub_url}"
  if ! curl -s --fail -k ${primehub_url}; then
    error "[Error] Can not access URL: ${primehub_url}"
    exit 1
  fi
  echo ""
}

prepare_primehub_env() {
  local CONFIG_PATH="$(primehub_config_path)"
  local HELM_OVERRIDE_PATH="$CONFIG_PATH/helm_override"

  if [ ! -f ${CONFIG_PATH}/.env ]; then
    info "[Prepare] PrimeHub require values"
    prepare_env_varible PRIMEHUB_DOMAIN || (usage_PRIMEHUB_DOMAIN; exit 1)
    prepare_env_varible KC_PASSWORD || (info "Will auto generate KC_PASSWORD for you."; true)
    prepare_env_varible PH_PASSWORD || (info "Will auto generate PH_PASSWORD for you."; true)

    if [[ "$PH_PASSWORD" == "" ]]; then
      PH_PASSWORD=$(openssl rand -hex 16)
    fi
    if [[ "$KC_PASSWORD" == "" ]]; then
      KC_PASSWORD=$(openssl rand -hex 16)
    fi

    if [[ "${CONTAINER_REGISTRY}" != "" ]]; then
      export PRIMEHUB_CONTROLLER_CUSTOM_IMAGE_REGISTRY_ENDPOINT="http://${CONTAINER_REGISTRY}"
      prepare_env_varible PRIMEHUB_CONTROLLER_CUSTOM_IMAGE_REGISTRY_USERNAME || true
      prepare_env_varible PRIMEHUB_CONTROLLER_CUSTOM_IMAGE_REGISTRY_PASSWORD || true
      export PRIMEHUB_CONTROLLER_CUSTOM_IMAGE_REGISTRY_USERNAME
      export PRIMEHUB_CONTROLLER_CUSTOM_IMAGE_REGISTRY_PASSWORD
      export PRIMEHUB_CONTROLLER_CUSTOM_IMAGE_REPO_PREFIX=${CONTAINER_REGISTRY}
    fi

    export PRIMEHUB_SCHEME
    export PRIMEHUB_DOMAIN
    export KC_DOMAIN=${PRIMEHUB_DOMAIN}
    export KC_SCHEME=${PRIMEHUB_SCHEME}
    export KC_USER="keycloak"
    export KC_REALM="primehub"
    export PRIMEHUB_STORAGE_CLASS="$(kubectl get sc | grep 'default' | cut -d ' ' -f 1)"
    export PRIMEHUB_NAMESPACE
    export PH_PASSWORD
    export KC_PASSWORD
    
    info "[Init] primehub config"
    mkdir -p "${CONFIG_PATH}"
    init_env
  else
    set -a; source $(primehub_config_path)/.env; set +a
  fi

  verify_primehub_domain ${PRIMEHUB_DOMAIN}
}

install_metacontroller() {
  if [[ $(helm ls metacontroller) == "" ]]; then
    info "[Install] Metacontroller"
    helm repo add infuseai https://charts.infuseai.io
    helm repo update
    helm install infuseai/metacontroller --namespace metacontroller --name metacontroller
  fi
  kubectl -n metacontroller rollout status sts/metacontroller
  kubectl get pod -n metacontroller
}

apply_issuer() {
  local CONFIG_PATH="$(primehub_config_path)"
  local ISSUER_CONFIG="${CONFIG_PATH}/issuer.yml"

  cat << EOF > ${ISSUER_CONFIG}
apiVersion: cert-manager.io/v1alpha2
kind: ClusterIssuer
metadata:
  name: letsencrypt-prod
spec:
  acme:
    email: phadmin@${PRIMEHUB_DOMAIN}
    server: https://acme-v02.api.letsencrypt.org/directory
    privateKeySecretRef:
      # Secret resource used to store the account's private key.
      name: letsencrypt
    # Add a single challenge solver, HTTP01 using nginx
    solvers:
    - http01:
        ingress:
          class: nginx
EOF

  local n=0
  until [ "${n}" -ge 3 ]
  do
    if kubectl apply -f ${ISSUER_CONFIG}; then
      break
    fi
    warn "[Retry] wait 10 seconds"
    n=$((n+1))
    sleep 10
  done

  if [ "${n}" -ge 3 ]; then
    error "[Fail] apply cluster issuer"
    exit 1
  fi
}

install_cert_manager() {
  if [[ $(helm ls cert-manager) == "" ]]; then
    info "[Install] Cert Manager"
    helm repo add jetstack https://charts.jetstack.io
    helm repo update
    helm install \
      --name cert-manager \
      --namespace cert-manager \
      --version v0.15.0 \
      jetstack/cert-manager \
      --set installCRDs=true \
      --set ingressShim.defaultIssuerName=letsencrypt-prod \
      --set ingressShim.defaultIssuerKind=ClusterIssuer
    kubectl -n cert-manager rollout status Deployment/cert-manager-webhook
  fi

  if ! kubectl get clusterissuer | grep letsencrypt-prod; then
    info "[Apply] Cluster Issuer: letsencrypt-prod"
    apply_issuer
  fi
}

generate_keycloak_config() {
  local tls=''
  local KEYCLOAK_CONFIG=$(primehub_config_path)/keycloak-values.yaml
  set -a; source $(primehub_config_path)/.env; set +a

  if [[ "${KC_SCHEME}" == "https" ]]; then
    tls=$(cat <<EOF
    tls:
    - hosts:
      - ${PRIMEHUB_DOMAIN}
      secretName: id-tls
EOF
)
  fi

  info "[Generate] keycloak-values.yaml"
  local KEYCLOAK_DB_PASSWORD=$(openssl rand -hex 32)

  cat <<EOF > ${KEYCLOAK_CONFIG}
keycloak:
  extraInitContainers: |
    - name: theme-provider
      image: infuseai/primehub-keycloak-theme:microk8s-e1e29f10
      imagePullPolicy: IfNotPresent
      command:
        - sh
      args:
        - -c
        - |
          echo "Copying theme..."
          cp -R /primehub/* /theme-primehub/
      volumeMounts:
        - name: theme-primehub
          mountPath: /theme-primehub
  extraVolumeMounts: |
    - name: theme-primehub
      mountPath: /opt/jboss/keycloak/themes/primehub
  extraVolumes: |
    - name: theme-primehub
      emptyDir: {}
  ingress:
    enabled: true
    annotations:      
      kubernetes.io/ingress.class: nginx
      kubernetes.io/tls-acme: "true"    
      ingress.kubernetes.io/affinity: cookie
    hosts:
    - ${PRIMEHUB_DOMAIN}
    path: /auth
${tls}
  username: ${KC_USER}
  password: ${KC_PASSWORD}
  persistence:    
    deployPostgres: true
    dbVendor: postgres
    dbPassword: ${KEYCLOAK_DB_PASSWORD}
postgresql:
  persistence:
    enabled: true
    storageClass: ${PRIMEHUB_STORAGE_CLASS}
  postgresPassword: ${KEYCLOAK_DB_PASSWORD}
EOF

}

error_log_keycloak() {
  local log_name='keycloak.log'
  k logs -l app.kubernetes.io/instance=keycloak --tail=-1 > ${log_name}
  error "[Error] Generate Keycloak error log at ${log_name}."
}

install_keycloak() {
  local KEYCLOAK_CONFIG=$(primehub_config_path)/keycloak-values.yaml
  info "[Check] keycloak-values.yaml"
  set -a; source $(primehub_config_path)/.env; set +a

  if [ ! -f "${KEYCLOAK_CONFIG}" ]; then
    generate_keycloak_config
  else
    info "[Found] ${KEYCLOAK_CONFIG}"
  fi

  info "[Install] Keycloak"
  helm repo add codecentric https://codecentric.github.io/helm-charts
  helm repo update
  helm upgrade \
  --install \
  --reset-values \
  --namespace default  \
  --version 7.2.1\
  --values ${KEYCLOAK_CONFIG} \
  --timeout ${HELM_TIMEOUT} \
  keycloak codecentric/keycloak || (error_log_keycloak; exit 1)

  info "[Verify] Keycloak ready"
  kubectl -n default rollout status sts/keycloak

  if [[ "$PRIMEHUB_SCHEME" == 'http' ]]; then
    info "[Config] Keycloak to support external access by HTTP"
    kubectl -n default exec -it keycloak-0 -- \
    /opt/jboss/keycloak/bin/kcadm.sh config credentials \
    --server http://localhost:8080/auth \
    --realm master \
    --user ${KC_USER} \
    --password=${KC_PASSWORD}
    kubectl -n default exec -it keycloak-0 -- \
    /opt/jboss/keycloak/bin/kcadm.sh update realms/master -s "sslRequired=none"
  fi
}

config_singlenode() {
  error "[Not Support Action] config singlenode"
}

diff_singlenode() {
  error "[Not Support Action] diff singlenode"
}

config_keycloak() {
  local KEYCLOAK_CONFIG=$(primehub_config_path)/keycloak-values.yaml

  if [ -f ${KEYCLOAK_CONFIG} ]; then
    info "[Config] ${KEYCLOAK_CONFIG}"
    cat ${KEYCLOAK_CONFIG}
  else
    error "[No Keycloak Installed] Please install PrimeHub first."
  fi
}

diff_keycloak() {
  local KEYCLOAK_CONFIG=$(primehub_config_path)/keycloak-values.yaml
  info "[Check] keycloak-values.yaml"
  set -a; source $(primehub_config_path)/.env; set +a

  helm diff upgrade \
    --context 2 \
    --reset-values \
    --namespace default  \
    --version 7.2.1\
    --values ${KEYCLOAK_CONFIG} \
    keycloak codecentric/keycloak
}

config_primehub() {
  local PRIMEHUB_CONFIG=$(primehub_config_path)/primehub-values.yaml

  if [ -f ${PRIMEHUB_CONFIG} ]; then
    info "[Config] ${PRIMEHUB_CONFIG}"
    cat ${PRIMEHUB_CONFIG}
  else
    error "[No PrimeHub Installed] Please install PrimeHub first."
  fi
}

diff_primehub() {
  local PRIMEHUB_CONFIG=$(primehub_config_path)/primehub-values.yaml
  info "[Check] primehub-values.yaml"
  set -a; source $(primehub_config_path)/.env; set +a

  if [[ "${PRIMEHUB_PATH}" != "" ]]; then
    helm diff upgrade\
      --context 2 \
      --reset-values \
      --namespace ${PRIMEHUB_NAMESPACE} \
      --values ${PRIMEHUB_CONFIG} \
      primehub ${PRIMEHUB_PATH}/modules/charts/primehub
  else
    local chart_version=$(echo "${PRIMEHUB_VERSION}" | sed 's/^v//g')
    helm diff upgrade\
      --context 2 \
      --reset-values \
      --reset-values \
      --namespace ${PRIMEHUB_NAMESPACE} \
      --values ${PRIMEHUB_CONFIG} \
      --version ${chart_version} \
      --timeout ${HELM_TIMEOUT} \
      primehub infuseai/primehub
  fi
}

generate_primehub_config() {
  local tls=''
  local customImage=''
  local eeFeatures=''
  local PRIMEHUB_CONFIG=$(primehub_config_path)/primehub-values.yaml
  set -a; source $(primehub_config_path)/.env; set +a

  info "[Generate] primehub-value.yaml"

  if [[ "${PRIMEHUB_SCHEME}" == "https" ]]; then
    tls=$(cat <<EOF
  tls:
  - hosts:
    - ${PRIMEHUB_DOMAIN}
    secretName: hub-tls
EOF
)
  fi

  if [[ "${CONTAINER_REGISTRY}" != "" ]]; then
  customImage=$(cat <<EOF
customImage:
  enabled: true
  registryEndpoint: $PRIMEHUB_CONTROLLER_CUSTOM_IMAGE_REGISTRY_ENDPOINT
  registryUsername: $PRIMEHUB_CONTROLLER_CUSTOM_IMAGE_REGISTRY_USERNAME
  registryPassword: $PRIMEHUB_CONTROLLER_CUSTOM_IMAGE_REGISTRY_PASSWORD
  pushRepoPrefix: $PRIMEHUB_CONTROLLER_CUSTOM_IMAGE_REPO_PREFIX
EOF
)
  fi

  if [[ "${PRIMEHUB_MODE}" == "ee" ]]; then
    eeFeatures=$(cat <<EOF
jobSubmission:
  enabled: true
EOF
)
  fi

  cat <<EOF > ${PRIMEHUB_CONFIG}
primehub:
  mode: ${PRIMEHUB_MODE}
  scheme: ${PRIMEHUB_SCHEME}
  domain: ${PRIMEHUB_DOMAIN}
  keycloak:
    scheme: ${KC_SCHEME}
    domain: ${KC_DOMAIN}
    username: keycloak
    password: ${KC_PASSWORD}
bootstrap:
  usernmae: phadmin  
  password: ${PH_PASSWORD}
graphql:
  sharedGraphqlSecret: ${ADMIN_UI_GRAPHQL_SECRET_KEY}
groupvolume:
  storageClass: ${PRIMEHUB_STORAGE_CLASS}
ingress:
  annotations:
    ingress.kubernetes.io/affinity: cookie
    kubernetes.io/ingress.class: nginx
  hosts:
  -  ${PRIMEHUB_DOMAIN}
${tls}
jupyterhub:
  auth:
    state:
      cryptoKey: ${ADMIN_UI_GRAPHQL_SECRET_KEY}
  hub:
    db:
      pvc:
        storageClassName: ${PRIMEHUB_STORAGE_CLASS}
  proxy:
    secretToken: ${HUB_PROXY_SECRET_TOKEN}
  singleuser:
    storage:
      dynamic:
        storageClass: ${PRIMEHUB_STORAGE_CLASS}
${customImage}
${eeFeatures}
EOF

}

error_log_primehub() {
  local log_name='primehub.log'
  echo "=== Bootstrap ===" > ${log_name}
  kubectl logs -n ${PRIMEHUB_NAMESPACE} -l component=bootstrap --tail=-1 >> ${log_name}
  error "[Error] Generate PrimeHub error log at ${log_name}."
}

install_primehub() {
  local PRIMEHUB_CONFIG=$(primehub_config_path)/primehub-values.yaml
  info "[Check] primehub-value.yaml"
  set -a; source $(primehub_config_path)/.env; set +a

  if [ ! -f "${PRIMEHUB_CONFIG}" ]; then
    generate_primehub_config
  else  
    info "[Found] ${PRIMEHUB_CONFIG}"
  fi

  info "[Install] PrimeHub"
  if [[ "${PRIMEHUB_PATH}" != "" ]]; then
    helm upgrade \
      --install \
      --reset-values \
      --namespace ${PRIMEHUB_NAMESPACE} \
      --values ${PRIMEHUB_CONFIG} \
      --timeout ${HELM_TIMEOUT} \
      primehub ${PRIMEHUB_PATH}/modules/charts/primehub || (error_log_primehub; exit 1)
  else
    local chart_version=$(echo "${PRIMEHUB_VERSION}" | sed 's/^v//g')
    helm repo add infuseai https://charts.infuseai.io
    helm repo update
    helm upgrade \
      --install \
      --reset-values \
      --namespace ${PRIMEHUB_NAMESPACE} \
      --values ${PRIMEHUB_CONFIG} \
      --version ${chart_version} \
      --timeout ${HELM_TIMEOUT} \
      primehub infuseai/primehub || (error_log_primehub; exit 1)
  fi
  
  kubectl label node component=singleuser-server --all || true

  info "[Verify] PrimeHub ready"
  kubectl -n hub rollout status deploy/primehub-console

  info "[Completed] Install PrimeHub"
  PRIMEHUB_URL=${PRIMEHUB_SCHEME}://${PRIMEHUB_DOMAIN}
  KC_URL=${KC_SCHEME}://${KC_DOMAIN}/auth

  echo ""
  echo "  PrimeHub:   $PRIMEHUB_URL  ( phadmin / ${PH_PASSWORD} )"
  echo "  Id Server:  $KC_URL/admin/ ( ${KC_USER} / ${KC_PASSWORD} )"
  echo ""
}

create_keycloak() {
  preflight_check

  prepare_primehub_env

  if [[ "${PRIMEHUB_SCHEME}" == "https" ]]; then
    info "[Check] Cert Manager"
    install_cert_manager
  fi

  info "[Check] Keycloak"
  install_keycloak

  info "[Completed]"
}

create_primehub() {
  preflight_check

  prepare_primehub_env

  if [[ "${PRIMEHUB_SCHEME}" == "https" ]]; then
    info "[Check] Cert Manager"
    install_cert_manager
  fi

  info "[Check] Metacontroller"
  install_metacontroller

  info "[Check] Keycloak"
  install_keycloak

  info "[Install] PrimeHub"
  install_primehub

  info "[Completed]"
}

check_infrastructure() {
  if ! check_primehub_required_bin; then
    error "[Pre-check Failed] Not install PrimeHub requested app"
    exit 1
  fi

  if ! check_k8s_cluster; then
    error "[Pre-check Failed] No kubernetes cluster running"
    exit 1
  fi
}

check_keycloak() {
  check_infrastructure

  if [ "$(helm ls keycloak)" == "" ]; then
    error "[Pre-check] Not install Keycloak"
    exit 1
  fi
}

check_primehub() {
  check_infrastructure

  if [ "$(helm ls primehub)" == "" ]; then
    error "[Pre-check] Not install PrimeHub"
    exit 1
  fi
}

status_keycloak() {
  check_keycloak

  info "[Helm] Keycloak"
  helm list keycloak

  info "[Pods] default namespaces"
  kubectl get pods -n default
}

status_primehub() {
  check_primehub

  info "[Helm] Primehub"
  helm list primehub

  info "[Pods] hub namespaces"
  kubectl get pods -n hub
}

verify_action() {
  local action_target=${1}
  local verify_key=${2}

  warn "Please make sure want you are doing!!!"
  echo -n "To continue destroy the ${action_target}, please re-enter '${verify_key}' again > "
  read verify
  if [[ "${verify_key}" != "${verify}" ]]; then
    >&2 error "[Abort] failed to destroy ${action_target}"
    exit 1
  fi

  return 0
}

backup_config() {
  local config_path="$(primehub_config_path)"
  local backup_path=backup-config-$(date +'%Y%m%d%H%M')
  info "[Backup] ${config_path} -> $(realpath ${backup_path})"
  mkdir -p ${backup_path}
  cp -r ${config_path}/* ${backup_path} || true
  if [ -f "${config_path}/.env" ]; then
    cp ${config_path}/.env ${backup_path}/env || true
  fi

  info "[Backup] Primehub CRD -> $(realpath ${backup_path})/crd"
  mkdir -p ${backup_path}/crd
  for crd in $(kubectl get crd | grep primehub | cut -d' ' -f 1); do
    kubectl get ${crd} -n ${PRIMEHUB_NAMESPACE} -o yaml > ${backup_path}/crd/${crd}.yaml || true
  done

  info "[Backup] Primehub Secret -> $(realpath ${backup_path})/secret"
  mkdir -p ${backup_path}/secret
  kubectl get secret -n ${PRIMEHUB_NAMESPACE} -o yaml primehub-client-admin-notebook > ${backup_path}/secret/primehub-client-admin-notebook.yaml 2> /dev/null || true
  kubectl get secret -n ${PRIMEHUB_NAMESPACE} -o yaml primehub-client-admin-ui > ${backup_path}/secret/primehub-client-admin-ui.yaml 2> /dev/null || true
  kubectl get secret -n ${PRIMEHUB_NAMESPACE} -o yaml primehub-client-jupyterhub > ${backup_path}/secret/primehub-client-jupyterhub.yaml 2> /dev/null || true
}

destroy_keycloak() {
  check_infrastructure

  if [ "$(helm ls primehub)" != "" ]; then
    error "[Check] Please destroy Primehub first"
    exit 1
  fi

  verify_action "Keycloak" "Keycloak"

  "[Backup] config"
  backup_config

  info "[Delete] keycloak helm"
  helm delete --purge keycloak

  info "[Delete] keycloak database pvc"
  kubectl delete pvc data-keycloak-postgresql-0 || true

  info "[Delete] keycloak-values.yaml"
  rm -f $(primehub_config_path)/keycloak-values.yaml || true

  info "[Completed] Destroy Keycloak"
}

destroy_primehub() {
  check_infrastructure

  verify_action "Primehub" "PrimeHub"

  set -a; source $(primehub_config_path)/.env; set +a
  
  info "[Backup] config"
  backup_config

  info "[Delete] primehub helm"
  helm delete --purge primehub

  info "[Delete] Primehub CRD"
  kubectl get crd | grep primehub | cut -d ' ' -f 1 | xargs kubectl delete crd

  info "[Delete] PrimeHub Secret"
  kubectl delete secret -n ${PRIMEHUB_NAMESPACE} primehub-client-admin-notebook
  kubectl delete secret -n ${PRIMEHUB_NAMESPACE} primehub-client-admin-ui
  kubectl delete secret -n ${PRIMEHUB_NAMESPACE} primehub-client-jupyterhub

  info "[Delete] PrimeHub bootstrap job"
  kubectl delete job primehub-bootstrap -n ${PRIMEHUB_NAMESPACE} || ture

  info "[Delete] PrimeHub Realm"
  kubectl -n default exec -it keycloak-0 -- \
    /opt/jboss/keycloak/bin/kcadm.sh config credentials \
    --server http://localhost:8080/auth \
    --realm master \
    --user ${KC_USER} \
    --password=${KC_PASSWORD}
  kubectl -n default exec -it keycloak-0 -- \
    /opt/jboss/keycloak/bin/kcadm.sh delete realms/${KC_REALM} || true
  
  info "[Delete] PrimeHub Env"
  rm $(primehub_config_path)/.env || true
  rm $(primehub_config_path)/primehub-values.yaml || true

  info "[Completed] Destroy PrimeHub"
}

show_license() {
  check_primehub
  set -a; source $(primehub_config_path)/.env; set +a

  info "[PrimeHub License]"
  kubectl get license -n ${PRIMEHUB_NAMESPACE} -o yaml | grep status: -A5
}

apply_license() {
  check_primehub
  set -a; source $(primehub_config_path)/.env; set +a
  local license_path=${LICENSE_PATH:-$(search_primehub_license)}

  if [[ ${license_path} == "" ]]; then
    warn "[Skip] license_crd.yml not found"
    exit 1
  fi

  info "[Verify] ${license_path}"
  kubectl apply -n {PRIMEHUB_NAMESPACE} -f ${license_path} --dry-run || (error "[Fail] license not avalible")

  info "[Apply] ${license_path}"
  kubectl apply -n ${PRIMEHUB_NAMESPACE} -f ${license_path}

  info "[Copmpleted] Create PrimeHub"
}

main() {
  local cmd=''
  local target=''
  local support_targets='singlenode keycloak primehub'
  while (( "$#" )); do
    case "${1:-}" in
      create|destroy|status|config|diff)
        if [[ "${cmd}" != '' ]]; then error 'Incorrect command'; usage; exit 1; fi
        cmd=${1}; shift
        for t in ${support_targets}; do
          if [[ "${t}" == "${1}" ]]; then
            target=${1}
            break
          fi
        done
        if [[ "${target}" == "" ]]; then
          usage
          exit 1
        fi
      ;;
      apply-license|license)
        if [[ "${cmd}" != '' ]]; then error 'Incorrect command'; usage; exit 1; fi
        cmd=${1};
      ;;
      --primehub-version)
        shift
        PRIMEHUB_VERSION=${1:-}
      ;;
      --k8s-version)
        shift
        for k8s_version in ${SUPPORT_K8S_VERSION}; do
          if [[ "${k8s_version}" == "${1:-}" ]]; then
            K8S_VERSION=${1:-}
          fi
        done
        if [[ "${K8S_VERSION}" == '' ]]; then error 'Unspport k8s version: ${1:-}'; usage; exit 1; fi
      ;;
      --namespace|-n)
        shift
        PRIMEHUB_NAMESPACE=${1:-}
      ;;
      --path)
        shift
        PRIMEHUB_PATH=${1:-}
      ;;
      --license-path)
        shift
        LICENSE_PATH=$(realpath ${1:-})
      ;;
      --enable-https)
        PRIMEHUB_SCHEME='https'
      ;;
      --primehub-ce)
        PRIMEHUB_MODE='ce'
      ;;
      --insecure-registry)
        shift
        INSECURE_REGISTRY=${1:-}
      ;;
      --custom-image)
        shift
        CONTAINER_REGISTRY=${1:-}
      ;;
      --helm-timeout)
        shift
        HELM_TIMEOUT=${1:-}
        local re='^[0-9]+$'
        if ! [[ ${HELM_TIMEOUT} =~ ${re} ]] ; then
          error "Unspport timeout input: ${HELM_TIMEOUT}"; usage; exit 1
        fi
      ;;
      --skip-domain-check)
        DOMAIN_CHECK=false
      ;;
      -h|--help)
        usage
        exit 0
      ;;
      --debug)
        set -x
      ;;
      *)
        error "Unsupport commnad: $1"
        usage
        exit 1
      ;;
    esac
    shift || (usage; exit 1)
  done


  case "$cmd" in
    create)
      prepare_primehub_release_tarball ${PRIMEHUB_VERSION} ${target}
      create_${target}
    ;;
    destroy)
      destroy_${target}
    ;;
    status)
      status_${target}
    ;;
    config)
      config_${target}
    ;;
    diff)
      prepare_primehub_release_tarball ${PRIMEHUB_VERSION} ${target}
      diff_${target}
    ;;
    license)
      show_license
    ;;
    apply-license)
      apply_license
    ;;
    *)
      usage
    ;;
  esac
}

main "$@"
